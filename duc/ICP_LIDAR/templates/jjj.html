<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LIDAR SLAM v√† ICP </title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/openseadragon/3.1.0/openseadragon.min.js"></script>
    <style>
        .stream-container {
            background-color:#E2D3F4;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .stop{
            text-align: center;
            background-color:hotpink;
            color:white;
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
        }
        .continue,.zoomIn,.zoomOut,.addpoint{
            text-align: center;
            background-color:rgb(28, 211, 49);
            color:white;
            padding: 10px 20px;
            border: 5px;
            border-radius: 10px;
        }
        .takePicture{
            text-align: center;
            background-color:yellowgreen;
            color:white;
            padding: 10px 20px;
            border: none;
            border-radius: 10px;
        }
        .takePicture:hover,.addpoint:hover{
            background-color:rgb(2, 238, 156);
            transform: scale(1.1);;
        }
        .stop:hover{
            background-color:red;
            transform: scale(0.9);;
        }
        .continue:hover{
            background-color:green;
            transform: scale(1.1);
        }
      .zoomIn:hover,.zoomOut:hover {
        background-color: darkgreen;
        transform: scale(1.1);
      }
      .controls-sidebar {
        max-height: calc(100vh - 80px);
        overflow-y: auto;
       }
    
        canvas.overlay {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
        }
    </style>
</head>
<body class="flex flex-col h-screen bg-[#96D6FF] text-gray-800 font-sans">

    <header class="flex-shrink-0 bg-white/30 shadow-md">
        <div class="container mx-auto px-4 py-3 flex justify-between items-center">
            <h1 style="color:orange" class="text-2xl font-bold">LiDAR SLAM and ICP Visualization</h1>
            <p id="status-message" class="text-lg text-blue-800 font-semibold h-6"></p>
            <p id="rmse-display" class="text-lg text-yellow-600 font-semibold h-6"></p>
            <p id="distance-display" class="text-lg text-green-600 font-semibold h-6"></p>
        </div>
    </header>


    <main class="flex-grow flex flex-row gap-4 p-4 overflow-hidden">
        <div id="mapViewer" class="flex-grow h-full rounded-lg shadow-lg bg-[#333] relative"></div>
        
   
        <aside class="flex-shrink-0 w-72 flex flex-col space-y-4 controls-sidebar">
  
       

            <div class="p-4 rounded-lg shadow flex flex-col space-y-3" style="background-color: rgba(255,255,255,0.3);">
                <h3 class="text-lg font-semibold mb-2 text-gray-800 text-center">ƒêi·ªÅu khi·ªÉn</h3>
       

                <button id="stop-button" class="stop w-full" onclick="stopStream()">‚ùå D·ª´ng</button>
                <button id="continue-button" class="continue w-full" onclick="resumeStream()">‚úÖ Ti·∫øp t·ª•c</button>
                <button id="take-picture-button" class="takePicture w-full" onclick="takePicture()">üì∑ Ch·ª•p ·∫¢nh</button>
                <button id="add-point-button" class="addpoint w-full" onclick="addPointOfInterest()">üìç Th√™m ƒêi·ªÉm </button>
            </div>

            <div id="camera-info-panel" class="p-4 rounded-lg shadow flex-col space-y-2" style="background-color: rgba(255,255,255,0.3); display: none;">
                <h3 class="text-lg font-semibold mb-2 text-gray-800 text-center">Th√¥ng s·ªë Pallet</h3>
                <p id="pallet-angle" class="text-sm"></p>
                <p id="camera-angle" class="text-sm"></p>
                <p id="pallet-distance" class="text-sm"></p>
                <p id="pallet-deviation" class="text-sm"></p>
                <p id="pallet-direction" class="text-sm font-bold text-center"></p>
            </div>


            <div class="p-4 rounded-lg shadow flex flex-col space-y-3" style="background-color: rgba(255,255,255,0.3);">
                <h3 class="text-lg font-semibold mb-2 text-gray-800 text-center">L∆∞u b·∫£n ƒë·ªì</h3>
                <input type="text" id="filename-input" placeholder="nhap_ten_ban_do" class="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-pink-500 bg-white text-gray-700">
                <select id="filetype-select" class="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-pink-500 bg-white text-gray-700">
                    <option value=".png">.png</option>
                    <option value=".jpg">.jpg</option>
                    <option value=".npy">.npy</option>
                    <option value=".pcd">.pcd</option>
                </select>
                <button id="save-map-button" class="takePicture w-full" style="background-color: #8A2BE2;" onclick="saveMap()">üíæ L∆∞u B·∫£n ƒê·ªì</button>
            </div>
  
            <div class="p-4 rounded-lg shadow flex flex-col space-y-3" style="background-color: rgba(255,255,255,0.3);">
                <h3 class="text-lg font-semibold mb-2 text-gray-800 text-center">Ch·ªçn ƒêi·ªÉm </h3>
                <select id="poi-select" class="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-pink-500 bg-white text-gray-700">
                    <option value="">-- Ch·ªçn ƒëi·ªÉm ƒë·ªÉ hi·ªÉn th·ªã --</option>
                </select>
                <button id="show-poi-button" class="continue w-full" onclick="showSelectedPoint()">Hi·ªÉn Th·ªã ƒêi·ªÉm</button>
                <button id="hide-poi-button" class="stop w-full" onclick="hideAllSelectedPoints()" style="display: none;">·∫®n ƒêi·ªÉm ƒê√£ Ch·ªçn</button>
            </div>

            <div class="p-4 rounded-lg shadow flex flex-col space-y-3" style="background-color: rgba(255,255,255,0.3);">
                <h3 class="text-lg font-semibold mb-2 text-gray-800 text-center">Hi·ªÉn th·ªã b·∫£n ƒë·ªì t·ª´ file</h3>
                <select id="saved-map-select" class="w-full px-3 py-2 border rounded-lg focus:outline-none focus:ring-2 focus:ring-pink-500 bg-white text-gray-700">
                    <option value="">-- Ch·ªçn file --</option>
                </select>
                <button id="show-map-button" class="continue w-full" onclick="showSavedMap()">üëÅÔ∏è Hi·ªÉn th·ªã</button>
                <button id="hide-map-button" class="stop w-full" onclick="hideSavedMap()" style="display: none;">·∫®n B·∫£n ƒê·ªì</button>
                <button id="toggle-points-button" class="takePicture w-full" style="background-color: #FFA500;" onclick="togglePoints()">·∫®n ƒêi·ªÉm</button>

            </div>
      
        </div>
    </div>
    <p id="status-message" class="mt-4 text-lg text-blue-800 font-semibold"></p>

<script>
    const statusMessage = document.getElementById('status-message');
    const mapViewerElement = document.getElementById('mapViewer');
    const savedMapSelect = document.getElementById('saved-map-select');

const viewer = OpenSeadragon({
    id: "mapViewer",
    prefixUrl: "https://cdnjs.cloudflare.com/ajax/libs/openseadragon/3.1.0/images/",
    tileSources: {
        type: 'image',
        url: '/map_image',
        buildPyramid: false
    },
    animationTime: 0.5,
    blendTime: 0.1,
    constrainDuringPan: true,
    maxZoomPixelRatio: 2,
    minZoomImageRatio: 0.5,
    visibilityRatio: 1,
    zoomPerScroll: 1.15,
   
    showZoomControl:      true,
    showHomeControl:      true,
    showFullPageControl:  true  
});

    let pointsVisible = true;

    function togglePoints() {
        pointsVisible = !pointsVisible;
        const btn = document.getElementById('toggle-points-button');
        btn.textContent = pointsVisible ? '·∫®n ƒêi·ªÉm' : 'Hi·ªán ƒêi·ªÉm';
        redrawAllPoints();
    }

  
    let overlayCanvas = null;
    let ctx = null;

    // C√°c bi·∫øn tr·∫°ng th√°i
    let globalMapPoints = []; // ƒê·ªïi t√™n t·ª´ latestScanPoints ƒë·ªÉ r√µ nghƒ©a h∆°n
    let robotPose = null; 
    let pointsOfInterest = [];
    let selectedPointsToDisplay = []; // M·∫£ng ch·ª©a ID c·ªßa c√°c ƒëi·ªÉm ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ hi·ªÉn th·ªã
    let eventSource; 
    let mapRefreshInterval = null; 


    function setupOverlay() {
        if (overlayCanvas) {
            overlayCanvas.remove();
        }
        overlayCanvas = document.createElement('canvas');
        overlayCanvas.classList.add('overlay');
        viewer.container.appendChild(overlayCanvas);
        ctx = overlayCanvas.getContext('2d');

        redrawAllPoints();
    }


    function redrawAllPoints() {

        if (!overlayCanvas || !ctx) {
            return;
        }
        const p = viewer.viewport.getBounds();
        const { x, y, width, height } = viewer.viewport.viewportToViewerElementRectangle(p);

        overlayCanvas.width = width;
        overlayCanvas.height = height;
        overlayCanvas.style.left = `${x}px`;
        overlayCanvas.style.top = `${y}px`;
        overlayCanvas.style.transformOrigin = `top left`;
        overlayCanvas.style.transform = `scale(${viewer.viewport.getContainerSize().x / width})`;
        
        ctx.clearRect(0, 0, overlayCanvas.width, overlayCanvas.height);
        if (!pointsVisible) return; // N·∫øu ƒëang ·∫©n, kh√¥ng v·∫Ω g√¨

        const zoom = viewer.viewport.getZoom(true);
        const pointRadius = Math.max(0.5, 1.5 * zoom / viewer.viewport.getMaxZoom());

        // V·∫Ω c√°c ƒëi·ªÉm ƒë∆∞·ª£c ch·ªçn ƒë·ªÉ hi·ªÉn th·ªã d∆∞·ªõi d·∫°ng ch·∫•m tr√≤n
        ctx.fillStyle = "rgba(255, 20, 147, 1)"; // M√†u h·ªìng ƒë·∫≠m (Deep Pink)
        ctx.strokeStyle = "white";
        ctx.lineWidth = 2;
        selectedPointsToDisplay.forEach(pointId => {
            const pointToHighlight = pointsOfInterest.find(p => p.id === pointId);
            if (pointToHighlight) {
                const [px, py] = pointToHighlight.pos_px;
                const osdPoint = viewer.viewport.imageToViewerElementCoordinates(new OpenSeadragon.Point(px, py));
                
                // V·∫Ω ch·∫•m tr√≤n
                ctx.beginPath();
                ctx.arc(osdPoint.x, osdPoint.y, 8, 0, 2 * Math.PI); // B√°n k√≠nh 8
                ctx.fill();
                ctx.stroke();
            }
        });
     
        ctx.fillStyle = "rgba(255, 0, 255, 1.2)"; 
        // T·ªëi ∆∞u h√≥a: S·ª≠ d·ª•ng fillRect thay v√¨ arc ƒë·ªÉ v·∫Ω h√†ng ngh√¨n ƒëi·ªÉm nhanh h∆°n.
        const pointSize = Math.max(1, 2.5 * zoom / viewer.viewport.getMaxZoom());
        globalMapPoints.forEach(([px, py]) => { // px, py l√† t·ªça ƒë·ªô pixel tr√™n ·∫£nh g·ªëc
            const point = viewer.viewport.imageToViewerElementCoordinates(new OpenSeadragon.Point(px, py));
            // V·∫Ω m·ªôt h√¨nh vu√¥ng nh·ªè. Nhanh h∆°n ƒë√°ng k·ªÉ so v·ªõi v·∫Ω h√¨nh tr√≤n.
            ctx.fillRect(point.x - pointSize / 2, point.y - pointSize / 2, pointSize, pointSize);
        });

        // V·∫Ω robot (h√¨nh ch·ªØ nh·∫≠t c√≥ m≈©i t√™n)
        if (robotPose) {
            const robotCenter = viewer.viewport.imageToViewerElementCoordinates(new OpenSeadragon.Point(robotPose.x, robotPose.y));
            const distanceToTarget = parseFloat(document.getElementById('distance-display').textContent.replace('Kho·∫£ng c√°ch t·ªõi m·ª•c ti√™u: ', '').replace(' mm', ''));
            const robotEnd = viewer.viewport.imageToViewerElementCoordinates(new OpenSeadragon.Point(robotPose.ex, robotPose.ey));

            const angle = Math.atan2(robotEnd.y - robotCenter.y, robotEnd.x - robotCenter.x);
            const robotWidth = 12; // pixels
            const robotHeight = 20; // pixels

               ctx.save(); // L∆∞u tr·∫°ng th√°i canvas hi·ªán t·∫°i
            ctx.translate(robotCenter.x, robotCenter.y);
            ctx.rotate(angle);
            ctx.fillStyle = "rgba(0, 100, 255, 0.9)";
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1.5;
            ctx.fillRect(-robotHeight / 2, -robotWidth / 2, robotHeight, robotWidth);
            ctx.strokeRect(-robotHeight / 2, -robotWidth / 2, robotHeight, robotWidth);


            if (distanceToTarget <= 1000 && !isNaN(distanceToTarget)) {
                // V·∫Ω hai ƒë∆∞·ªùng th·∫≥ng song song
                
                const forkOffset = 8; // Kho·∫£ng c√°ch gi·ªØa hai c√†ng
                ctx.strokeStyle = "red";
                ctx.lineWidth = 3;

                ctx.beginPath();
                ctx.moveTo(robotHeight / 2, -forkOffset / 2);
                ctx.lineTo(robotHeight / 2 + 10, -forkOffset / 2); // ƒê·ªô d√†i c√†ng
                ctx.stroke();

                ctx.beginPath();
                ctx.moveTo(robotHeight / 2, forkOffset / 2);
                ctx.lineTo(robotHeight / 2 + 10, forkOffset / 2); // ƒê·ªô d√†i c√†ng
                ctx.stroke();
            } else {
               // V·∫Ω m≈©i t√™n m√†u ƒë·ªè thay v√¨ m√†u tr·∫Øng
               ctx.fillStyle = "rgba(255, 0, 0, 1)"; // M√†u ƒë·ªè
                ctx.beginPath();
                ctx.moveTo(robotHeight / 2, 0); // ƒê·ªânh m≈©i t√™n
                ctx.lineTo(robotHeight / 2 - 8, -5); // G√≥c tr√™n
                ctx.lineTo(robotHeight / 2 - 8, 5);  // G√≥c d∆∞·ªõi
                ctx.closePath(); // N·ªëi ƒëi·ªÉm cu·ªëi v·ªÅ ƒëi·ªÉm ƒë·∫ßu ƒë·ªÉ t·∫°o th√†nh h√¨nh tam gi√°c
                ctx.fill();
            }
             ctx.restore();
           }
    }

    viewer.addHandler('open', setupOverlay); 
    viewer.addHandler('animation', redrawAllPoints);
    viewer.addHandler('resize', redrawAllPoints);
    
    function startEventStream() {

        if (eventSource && eventSource.readyState !== EventSource.CLOSED) {
            eventSource.close();
        }
        if (mapRefreshInterval) {
            clearInterval(mapRefreshInterval);
        }

        // Reset c√°c bi·∫øn tr·∫°ng th√°i
        globalMapPoints = [];
        robotPose = null;

        // B·∫Øt ƒë·∫ßu lu·ªìng nh·∫≠n d·ªØ li·ªáu v·ªã tr√≠ robot v√† tia qu√©t m·ªõi nh·∫•t
        eventSource = new EventSource('/points_stream');
        eventSource.onmessage = function(event) {
         try {
            const data = JSON.parse(event.data);
            
            // X√≥a t·∫•t c·∫£ c√°c ƒëi·ªÉm c≈© v√† thay th·∫ø b·∫±ng ƒëi·ªÉm m·ªõi nh·∫•t
            if (data.points && Array.isArray(data.points)) {
                globalMapPoints = [...data.points];
            } else if (data.new_points && Array.isArray(data.new_points)) {
                globalMapPoints = [...data.new_points];
            } else {
                // C√≥ th·ªÉ th√™m x·ª≠ l√Ω l·ªói ho·∫∑c th√¥ng b√°o n·∫øu d·ªØ li·ªáu kh√¥ng c√≥ ƒëi·ªÉm h·ª£p l·ªá
                console.warn("G√≥i tin kh√¥ng ch·ª©a d·ªØ li·ªáu ƒëi·ªÉm h·ª£p l·ªá.");
            }
   

                if (data.pose) {
                    robotPose = data.pose;
                }

                const distanceDisplay = document.getElementById('distance-display');
                if (data.distance) {
                    distanceDisplay.textContent = `Kho·∫£ng c√°ch t·ªõi m·ª•c ti√™u: ${data.distance} mm`;
                } else if (distanceDisplay.textContent) {
                    distanceDisplay.textContent = ''; // X√≥a n·∫øu kh√¥ng c√≥ d·ªØ li·ªáu
                }

                // C·∫≠p nh·∫≠t RMSE
                const rmseDisplay = document.getElementById('rmse-display');
                if (data.rmse) {
                    rmseDisplay.textContent = `ICP RMSE: ${data.rmse}`;
                } else if (rmseDisplay.textContent) {
                    rmseDisplay.textContent = '';
                }

                // C·∫≠p nh·∫≠t th√¥ng tin camera/pallet
                const cameraPanel = document.getElementById('camera-info-panel');
                if (data.camera_data) {
                    document.getElementById('pallet-angle').textContent = `G√≥c nghi√™ng Pallet: ${data.camera_data.angle_deg.toFixed(2)}¬∞`;
                    // Hi·ªÉn th·ªã g√≥c l·ªách so v·ªõi h∆∞·ªõng th·∫≥ng (180 ƒë·ªô)
                    document.getElementById('camera-angle').textContent = `G√≥c l·ªách Camera: ${(180 - data.camera_data.angle_horizontal_deg).toFixed(2)}¬∞`;
                    document.getElementById('pallet-distance').textContent = `Kho·∫£ng c√°ch: ${data.camera_data.mean_depth.toFixed(2)} mm`;
                    document.getElementById('pallet-deviation').textContent = `ƒê·ªô l·ªách ngang: ${data.camera_data.dis_lech.toFixed(2)} mm`;
                    document.getElementById('pallet-direction').textContent = `H∆∞·ªõng: ${data.camera_data.chieu_lech}`;
                    cameraPanel.style.display = 'flex'; // Hi·ªÉn th·ªã panel
                } else {
                    cameraPanel.style.display = 'none'; // ·∫®n panel n·∫øu kh√¥ng c√≥ d·ªØ li·ªáu
                }

                redrawAllPoints(); 
            } catch (e) {
                console.error("L·ªói x·ª≠ l√Ω d·ªØ li·ªáu stream:", e);
            }
        };

    }

    // --- C√ÅC H√ÄM ƒêI·ªÄU KHI·ªÇN ---
    function showStatus(message, duration = 3000) {
        statusMessage.textContent = message;
        if (duration > 0) {
            setTimeout(() => { statusMessage.textContent = ''; }, duration);
        }
    }

    function stopStream() {
        // D·ª´ng lu·ªìng nh·∫≠n ƒëi·ªÉm
        if (eventSource) {
            eventSource.close();
        }
        // D·ª´ng l√†m m·ªõi ·∫£nh n·ªÅn
        if (mapRefreshInterval) {
            clearInterval(mapRefreshInterval);
            mapRefreshInterval = null;
        }
        fetch('/stop_stream').then(r => r.json()).then(data => showStatus(data.message));
    }

    function resumeStream() {

        fetch('/resume_stream').then(r => r.json()).then(data => showStatus(data.message));

        startEventStream();
    }

    function takePicture() {
        fetch('/save_frame').then(r => r.json()).then(data => {
            if (data.status === 'success') showStatus(`·∫¢nh ƒë√£ ƒë∆∞·ª£c l∆∞u: ${data.filename}`);
            else showStatus(`L·ªói: ${data.message}`);
        });
    }

    function addPointOfInterest() {
        showStatus('ƒêang th√™m ƒëi·ªÉm...', 0);
        fetch('/add_point', { method: 'POST' })
            .then(response => response.json())
            .then(data => {
                if (data.status === 'success') {
                    showStatus('‚úÖ ƒê√£ th√™m ƒëi·ªÉm th√†nh c√¥ng!');
                    fetchPointsOfInterest(); // T·∫£i l·∫°i danh s√°ch ƒë·ªÉ c·∫≠p nh·∫≠t ngay
                } else {
                    showStatus(`‚ùå L·ªói: ${data.message}`);
                }
            })
            .catch(err => {
                showStatus('‚ùå L·ªói k·∫øt n·ªëi server khi th√™m ƒëi·ªÉm.');
                console.error(err);
            });
    }

    function fetchPointsOfInterest() {
        fetch('/get_points_of_interest')
            .then(response => response.json())
            .then(data => {
                if (data.points) {
                    pointsOfInterest = data.points;
                    // C·∫≠p nh·∫≠t dropdown
                    const poiSelect = document.getElementById('poi-select');
                    poiSelect.innerHTML = '<option value="">-- Ch·ªçn ƒëi·ªÉm ƒë·ªÉ hi·ªÉn th·ªã --</option>'; // X√≥a c√°c l·ª±a ch·ªçn c≈©
                    pointsOfInterest.forEach(point => {
                        const option = document.createElement('option');
                        option.value = point.id;
                        option.textContent = point.name;
                        poiSelect.appendChild(option);
                    });
                    redrawAllPoints(); // V·∫Ω l·∫°i canvas v·ªõi c√°c ƒëi·ªÉm m·ªõi
                }
            })
            .catch(err => console.error("Kh√¥ng th·ªÉ t·∫£i ƒëi·ªÉm :", err));
    }

    function showSelectedPoint() {
        const poiSelect = document.getElementById('poi-select');
        const selectedId = parseInt(poiSelect.value, 10);

        if (isNaN(selectedId)) {
            showStatus("Vui l√≤ng ch·ªçn m·ªôt ƒëi·ªÉm t·ª´ danh s√°ch.");
            return;
        }

        // G·ª≠i y√™u c·∫ßu t·ªõi server ƒë·ªÉ ƒë·∫∑t ƒëi·ªÉm n√†y l√†m m·ª•c ti√™u
        fetch('/set_active_target', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: selectedId })
        })
        .then(response => response.json())
        .then(data => console.log(data.message));

        // Th√™m ID v√†o danh s√°ch hi·ªÉn th·ªã n·∫øu ch∆∞a c√≥
        if (!selectedPointsToDisplay.includes(selectedId)) {
            selectedPointsToDisplay.push(selectedId);
            redrawAllPoints();
            document.getElementById('hide-poi-button').style.display = 'block';
            showStatus(`ƒê√£ hi·ªÉn th·ªã ${poiSelect.options[poiSelect.selectedIndex].text}`);
        } else {
            showStatus("ƒêi·ªÉm n√†y ƒë√£ ƒë∆∞·ª£c hi·ªÉn th·ªã.");
        }
    }

    function hideAllSelectedPoints() {
        // G·ª≠i y√™u c·∫ßu t·ªõi server ƒë·ªÉ h·ªßy m·ª•c ti√™u
        fetch('/set_active_target', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ id: null })
        })
        .then(response => response.json())
        .then(data => console.log(data.message));

        selectedPointsToDisplay = [];
        redrawAllPoints();
        document.getElementById('hide-poi-button').style.display = 'none';
        showStatus("ƒê√£ ·∫©n t·∫•t c·∫£ c√°c ƒëi·ªÉm ƒë∆∞·ª£c ch·ªçn.");
    }

    function saveMap() {
        const filenameInput = document.getElementById('filename-input');
        const filetype = document.getElementById('filetype-select').value;
        const filenameBase = filenameInput.value.trim() || filenameInput.placeholder;

        if (!filenameBase) {
            showStatus('L·ªói: Vui l√≤ng nh·∫≠p t√™n file.');
            return;
        }

        const fullFilename = filenameBase + filetype;
        showStatus(`ƒêang l∆∞u ${fullFilename}...`, 0);

        fetch(`/save_map?filename=${encodeURIComponent(fullFilename)}`)
            .then(response => response.json())
            .then(data => {
                showStatus(data.message);
                if (data.status === 'success') {
                    fetchSavedMaps(); // T·∫£i l·∫°i danh s√°ch file
                }
            });
    }

    function fetchSavedMaps() {
        fetch('/list_saved_files')
            .then(response => response.json())
            .then(data => {
                savedMapSelect.innerHTML = '<option value="">-- Ch·ªçn file --</option>';
                if (data.files) {
                    data.files.forEach(file => {
                        const option = document.createElement('option');
                        option.value = file;
                        option.textContent = file;
                        savedMapSelect.appendChild(option);
                    });
                }
            });
    }

    // *** H√ÄM QUAN TR·ªåNG NH·∫§T ***
    async function showSavedMap() {
        const pngFilename = savedMapSelect.value;
        if (!pngFilename) {
            showStatus('Vui l√≤ng ch·ªçn m·ªôt file.');
            return;
        }

        // 1. D·ª´ng lu·ªìng th·ªùi gian th·ª±c v√† l√†m m·ªõi b·∫£n ƒë·ªì
        if (eventSource && eventSource.readyState !== EventSource.CLOSED) {
            eventSource.close();
        }
        if (mapRefreshInterval) {
            clearInterval(mapRefreshInterval);
            mapRefreshInterval = null;
        }

        robotPose = null; // X√≥a v·ªã tr√≠ robot c≈©
        globalMapPoints = []; // X√≥a c√°c ƒëi·ªÉm qu√©t m·ªõi nh·∫•t
        redrawAllPoints(); // V·∫Ω l·∫°i canvas tr·ªëng
        showStatus(`ƒêang t·∫£i b·∫£n ƒë·ªì ${pngFilename}...`, 0);

       
        viewer.open({
            type: 'image',
            url: `/get_map_image/${pngFilename}`,
            buildPyramid: false
        });
        
        try {
            const serverUpdateResponse = await fetch('/load_map_for_imshow', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ filename: pngFilename }),
            });
            const serverUpdateData = await serverUpdateResponse.json();
            if (serverUpdateData.status === 'success') {
                console.log("Server successfully updated its display.");
                showStatus(`ƒê√£ t·∫£i b·∫£n ƒë·ªì ${pngFilename}. SLAM v·∫´n ch·∫°y trong n·ªÅn.`);
            } else {
                console.error("Server failed to update display:", serverUpdateData.message);
                showStatus(`L·ªói server: ${serverUpdateData.message}`);
            }

            // Hi·ªÉn th·ªã/·∫©n c√°c n√∫t ph√π h·ª£p
            document.getElementById('hide-map-button').style.display = 'block';
            document.getElementById('show-map-button').style.display = 'none';
            startEventStream();
        } catch (error) {
            console.error('L·ªói khi hi·ªÉn th·ªã b·∫£n ƒë·ªì ƒë√£ l∆∞u:', error);
            showStatus('L·ªói khi hi·ªÉn th·ªã b·∫£n ƒë·ªì ƒë√£ l∆∞u.');
        }
    }


   
    function hideSavedMap() {
        // H√†m n√†y s·∫Ω x·ª≠ l√Ω vi·ªác quay l·∫°i ch·∫ø ƒë·ªô xem th·ªùi gian th·ª±c
        resumeStream();
        // C·∫≠p nh·∫≠t giao di·ªán n√∫t b·∫•m
        document.getElementById('hide-map-button').style.display = 'none';
        document.getElementById('show-map-button').style.display = 'block';
    }

    document.addEventListener('DOMContentLoaded', () => {
        fetchSavedMaps();
        fetchPointsOfInterest(); // T·∫£i c√°c ƒëi·ªÉm ƒë√£ l∆∞u khi trang ƒë∆∞·ª£c m·ªü
        viewer.world.addHandler('add-item', () => redrawAllPoints());
        startEventStream(); // Start stream on page load
    });

</script>
</body>
</html>